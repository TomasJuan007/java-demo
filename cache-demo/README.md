## 业务需求：
查询数据库获取登录代理人所有的有权限的多层级菜单，并且展示常用菜单和置顶菜单

## 问题描述：
2022年3月4号，有权限的托管保单的菜单（子菜单）查询不到，但是日志可以查询到，日志之后的数据没有对一级菜单更新；
同事在返回结果前补充日志，确定丢失了数据

## 实现逻辑：
数据库保存菜单，用户常用菜单，置顶菜单，返回具有层级的一级菜单列表，常用菜单ID列表，置顶菜单Id列表
从内存缓存获取allMenu，然后对所有level为1的菜单填充子菜单（这里的一级菜单直接使用了缓存列表中的对象），最终返回包含子菜单的一级菜单

## 分析可能原因：
缓存有失效机制，假如第一个线程还没执行完缓存失效(到达预刷时间)，
新来的线程更新allMenu，如果allMenu在堆中，则与第一个线程的allMenu共享，
此时第一个线程的一级菜单的子菜单就会被更新为null

## 复现：
不使用克隆情况下，通过以下操作，证实不同线程写同一个对象
1.调用/test接口，重复调用，查看日志发现不同线程返回同一个对象
2.调用/test?skipInject=true（模拟缓存刷新），三秒内调用/test，注入子菜单，发现第一次调用产生的对象被修改，即使没有注入二级菜单，结果中也返回了二级菜单

## 出现问题的原因：
数据源头方面：因为ehcache缓存会返回同一个对象，导致不同线程共享一个对象；
数据使用方面：lambda表达式过滤不会生成新对象，导致后续操作直接对缓存的对象修改

## 解决方案：
1.缓存切面处深拷贝一个新的对象返回，防止不同线程互相影响
2.在JVM缓存一个不可变对象，获取后如果需要修改手动深拷贝

浅拷贝方式对比：
1. native
- Java clone
2. reflect
- Apache BeanUtils、Spring BeanUtils、Hutool BeanUtils、 Apache BeanCopier
3. getter/setter
- MapStruct

深拷贝方式对比：
1. native：
- Serializable
2. json：
- Jackson、Gson、FastJson
3. binary：
- Kryo、Orika
4. binary protocol:
- Protobuf、Thrift、Avro、Hessian

在缓存切面处深拷贝场景下：
- 浅拷贝的方式不适用
- 对于原生方式，Serializable方式需要对所有类修改，实现Serializable接口
- 对于JSON序列化方式，可能存在性能问题
- 对于二进制序列化方式，需要通过方法返回值的类型，提前注册处理类，如果返回值类型不是对象实例的实际类型受局限
- 对于序列化协议框架，主要用于跨语言、跨平台的场景，大部分不支持动态特性，并且可能存在性能问题

综上，如果使用方案一，在追求性能、需要动态生成代码、无代码侵入的场景下，只能Kryo等使用字节码技术的框架；
建议使用方案二，在使用JVM缓存时，将缓存内容限制为不可变，保证缓存的对象不可修改

## 复盘：
对缓存框架的原理要理解透彻，从内存中获取缓存数据时，如果修改数据需要返回一个新对象，小心地使用内存中的共享数据